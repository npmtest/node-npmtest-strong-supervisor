{"/home/travis/build/npmtest/node-npmtest-strong-supervisor/test.js":"/* istanbul instrument in package npmtest_strong_supervisor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/lib.npmtest_strong_supervisor.js":"/* istanbul instrument in package npmtest_strong_supervisor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_strong_supervisor = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_strong_supervisor = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-strong-supervisor && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_strong_supervisor */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_strong_supervisor\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_strong_supervisor.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_strong_supervisor.rollup.js'] =\n            local.assetsDict['/assets.npmtest_strong_supervisor.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_strong_supervisor.__dirname +\n                    '/lib.npmtest_strong_supervisor.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/index.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\n// For `slc --version` to report strong-agent version\nexports.__module = module;\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/adapter.js":"// Copyright IBM Corp. 2016,2017. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar assert = require('assert');\nvar appmetrics; // = require('appmetrics') if started\nvar appmetricsStarted = false; // XXX(sam) always === !!appmetrics, can remove?\nvar dashboard = require('./dashboard');\nvar debug = require('./debug')('adapter');\nvar monitor;\nvar util = require('util');\n\n// Export an EventEmitter\n\nmodule.exports = exports = new EventEmitter;\n\n// Export the desired functions\nvar metrics = {\n  startCpuProfiling: startCpuProfiling,\n  stopCpuProfiling: stopCpuProfiling,\n  startTrackingObjects: startTrackingObjects,\n  stopTrackingObjects: stopTrackingObjects\n};\n\nvar internal = {\n  on: internal_on, // XXX(sam) where is this used?\n  supports: {watchdog: false} // XXX(sam) probably not needed\n};\n\nvar dyninst = {\n  metrics: false\n};\n\nexports.use = use;\nexports.metrics = metrics;\nexports.profile = profile;\nexports.start = start;\nexports.internal = internal;\nexports.dyninst = dyninst;\nexports.lrtime = lrtime;\n\n\n// Global objects to store metric data\nvar eventLoopMetrics = {\n  count: 0,\n  minimum: 0,\n  maximum: 0,\n  average: 0,\n};\nvar cpuMetrics = {\n  system: 0,\n  user: 0,\n  count: 0,\n};\nvar httpMetrics = {\n  count: 0,\n};\nvar probeList = [\n  'leveldown',\n  'memcached',\n  'mongo',\n  'mysql',\n  'oracle',\n  'oracledb',\n  'postgres',\n  'redis',\n  'socketio',\n  'strong-oracle',\n  'express',\n];\nvar probeMetrics = {};\nvar heapMetrics = {\n  total: 0,\n  used: 0,\n  count: 0,\n};\nvar gcMetrics = {\n  used: 0,\n  count: 0,\n};\nvar messageMetrics = {\n  sent: 0,\n  received: 0,\n};\n\n// Keep track of Cpu Profiling\nvar profiling = false;\nvar objectTrackingEnabled = false;\nvar lastObjectHistogram = {};\n\n// Callback interval\nvar callbackInterval = process.env.STRONGLOOP_BASE_INTERVAL || 60000;\nvar objectTrackingCallbackInterval =\n  process.env.STRONGLOOP_OBJECT_TRACKING_INTERVAL || 15000;\n\n// Public functions to be exported\n\n// Metrics API Use function\nfunction use(callback) {\n\n  // The callback needs to fire every 60 seconds with data from the last 60\n  // seconds\n  setInterval(function() {\n    // Get data from last 60 seconds\n    var eventLoopData = getEventLoopData();\n    var cpuData = getCpuData();\n    var httpData = getHttpData();\n    var heapData = getHeapData();\n    var usedHeap = getGcHeapData();\n    var messageData = getMessageData();\n\n    debug('eventLoopData: %j', eventLoopData);\n\n    if (eventLoopData.count > 0) {\n      // This function can run before data collection has started, in which case\n      // there is no data, and min/max/average are undefined. Skip reporting\n      // until data arrives.\n      callback('loop.count', assertPositive(eventLoopData.count));\n      callback('loop.minimum', assertPositive(eventLoopData.minimum));\n      callback('loop.maximum', assertPositive(eventLoopData.maximum));\n      callback('loop.average', assertPositive(eventLoopData.average));\n    }\n\n    debug('cpuData: %j', cpuData);\n\n    if (cpuData.count) {\n      // This function can run before any CPU data has been collected. Avoid\n      // reporting unknown or invalid values by just not reporting if there\n      // is no data.\n      callback('cpu.system', assertPositive(cpuData.system));\n      callback('cpu.total', assertPositive(cpuData.total));\n      callback('cpu.user', assertPositive(cpuData.user));\n    }\n\n    callback('http.connection.count', assertPositive(httpData.count));\n\n    // Callback with probe data of each probe if there have been events\n    var probeData;\n\n    for (var i in probeList) {\n      if (probeMetrics[probeList[i]]) {\n        probeData = getProbeData(probeList[i]);\n        callback(probeList[i] + '.count', assertPositive(probeData.count));\n        callback(probeList[i] + '.average', assertPositive(probeData.average));\n        callback(probeList[i] + '.minimum', assertPositive(probeData.minimum));\n        callback(probeList[i] + '.maximum', assertPositive(probeData.maximum));\n      }\n    }\n\n    if (usedHeap > 0) {\n      callback('gc.heap.used', usedHeap);\n    }\n\n    if (heapData.total && heapData.used) {\n      callback('heap.total', assertPositive(heapData.total));\n      callback('heap.used', assertPositive(heapData.used));\n    }\n\n    if (messageData.sent > 0 || messageData.received > 0) {\n      callback('messages.out.count', messageData.sent);\n      callback('messages.in.count', messageData.received);\n    }\n\n  }, callbackInterval).unref();\n\n  setInterval(function() {\n    var version = process.version.split('v')[1];\n    if (objectTrackingEnabled) {\n      if (version >= '0.11') {\n        var histogram = appmetrics.getObjectHistogram();\n        require('fs').writeFileSync('histogram-' + Date.now() + '.json',\n                                    JSON.stringify(histogram));\n        var objectCounts = compareHistograms(lastObjectHistogram, histogram);\n        lastObjectHistogram = histogram;\n        // Get object stats\n        for (var type in objectCounts) {\n          var tuple = objectCounts[type];\n          // Don't output events for no change?\n          // XXX(toby) - What's the correct behaviour here?\n          // XXX(toby) - Should we skip \"weird\" object types?\n          // FIXME(toby) I'll have to read the strong-agent code to see how what\n          // you are doing is different, but if you look at histogram.json I\n          // checked in, you'll see many of the types are pure garbage. I wonder\n          // if non-string things like functions are being coerced into strings?\n          // The entire source code of files is showing up as 'types'!\n          if (type.indexOf('\\n') >= 0) {\n            console.trace('%j', type);\n            console.assert(type.indexOf('\\n') < 0, 'INVALID');\n          } else {\n            if (tuple.count !== 0 && tuple.size !== 0) {\n              callback('object.' + type + '.count', tuple.count);\n              callback('object.' + type + '.size', tuple.size);\n            }\n          }\n        }\n      } else {\n        callback('Warning',\n                 'Object tracking is not supported on node v' + version);\n      }\n    }\n  }, objectTrackingCallbackInterval).unref();\n}\n\nfunction start(options) {\n  options = util._extend({}, options);\n\n  if (!appmetricsStarted) {\n    appmetrics = require('appmetrics');\n    appmetrics.configure(options); // FIXME are the options in agentOptions OK?\n    // FIXME confirm appmetrics.configure() accepts sl-run:agentOptions\n    appmetrics.enable('eventloop');\n    monitor = appmetrics.monitor();\n    initialise();\n    appmetricsStarted = true;\n\n    global.APPMETRICS = appmetrics;\n\n    var dash = dashboard(options.dashboard, appmetrics,\n                         require('appmetrics-dash'));\n\n    if (dash.path)\n      console.log('strong-supervisor attaching dashboard at %s', dash.path);\n\n    // XXX(sam) Unimplemented features?\n    // - watchdogActivationCount\n    // - express:usage-record\n\n    exports.on('newListener', function(type) {\n      switch (type) {\n        case 'express:usage-record':\n          // turn on express usage record\n          monitor.on('express:usage-record', function(record) {\n            exports.emit('express:usage-record', record);\n          });\n          break;\n      }\n    });\n\n  }\n}\n\nfunction internal_on() {\n\n}\n\n// Configuration of appmetrics/strong-agent.\n//\n// For backwards compatibility reasons, strong-agent had multiple APIs for\n// configuring and starting it.\n//\n// The agentOptions includes configuration properties used by strong-agent, but\n// currently ignored by appmetrics.  For definition of agentOptions, see\n// agentOptions in bin/sl-run.js.\n//\n// XXX(sam) appmetrics has configuration, lots of it, and its probably\n// worth making it possible to load configuration from disk and/or to\n// configure via CLI or ENV.\n\n// profile(unused, unused, agentOptions)\nfunction profile() {\n}\n\n// CPU Profiling\nfunction startCpuProfiling() {\n  start();\n  // If we aren't profiling already\n  if (!profiling) {\n    profiling = true;\n\n    // Instruct appmetrics to return JSON formatting and enable profiling\n    appmetrics.setJSONProfilingMode(true);\n    appmetrics.sendControlCommand('profiling_node', 'on,profiling_node_v8json');\n    appmetrics.enable('profiling');\n\n  }\n}\n\nfunction stopCpuProfiling(callback) {\n  if (profiling) {\n\n    // Listen for JSON coming back from appmetrics\n    monitor.once('profiling', function(data) {\n      callback(JSON.stringify(data));\n    });\n\n    profiling = false;\n    appmetrics.disable('profiling');\n  }\n}\n\n// Object tracking\nfunction startTrackingObjects() {\n  start();\n  objectTrackingEnabled = true;\n}\n\nfunction stopTrackingObjects() {\n  objectTrackingEnabled = false;\n  lastObjectHistogram = {};\n}\n\n// Private functions\n\n// Metrics API\nfunction isPositive(n) {\n  return typeof n === 'number' && n >= 0;\n}\n\nfunction assertPositive(n) {\n  assert(isPositive(n));\n  return n;\n}\n\nfunction createEventLoopListener() {\n  monitor.on('loop', function(res) {\n    // Update min and max accordingly\n    eventLoopMetrics.count = res.count;\n    eventLoopMetrics.minimum = res.minimum;\n    eventLoopMetrics.maximum = res.maximum;\n    eventLoopMetrics.average = res.average;\n  });\n}\n\nfunction createCpuListener() {\n  monitor.on('cpu', function(cpu) {\n    // CPU usage is reported periodically. The values are summed and counted, so\n    // that the average can be reported over the expected (backwards compatible\n    // to strong-agent) reporting period.\n    cpuMetrics.system += (cpu.system * 100);\n    cpuMetrics.user += (cpu.process * 100);\n    cpuMetrics.count++;\n  });\n}\n\nfunction createHeapListener() {\n  monitor.on('heap', function(res) {\n    heapMetrics.total += res.total;\n    heapMetrics.used += res.used;\n    heapMetrics.count++;\n  });\n}\n\nfunction createGcListener() {\n  monitor.on('gc', function(res) {\n    gcMetrics.used += res.used;\n    gcMetrics.count++;\n  });\n}\n\nfunction createHttpListener() {\n  /* eslint-disable no-unused-vars */\n  monitor.on('http', function(args) {\n    /* eslint-enable no-unused-vars */\n    // All we need to do is increment the count\n    httpMetrics.count++;\n  });\n}\n\nfunction createMessageListener() {\n  // Map the event types from axon and strong mq to whether they\n  // were send or receive events.\n  monitor.on('strong-mq', incrementCounts);\n  monitor.on('axon', incrementCounts);\n  function incrementCounts(data) {\n    var types = {\n      push: 'send',\n      pull: 'receive',\n      pub: 'send',\n      sub: 'receive',\n      req: 'send',\n      rep: 'receive',\n      'pub-emitter': 'send',\n      'sub-emitter': 'receive'\n    };\n    if (types[data.type] === 'send') {\n      messageMetrics.sent++;\n    } else if (types[data.type] === 'receive') {\n      messageMetrics.received++;\n    }\n  }\n}\n\nfunction createProbeListener(probeName) {\n  monitor.on(probeName, function(res) {\n    // If no metrics object exists, create one\n    if (!probeMetrics[probeName]) {\n      probeMetrics[probeName] = {\n        count: 0,\n        runningTotal: 0\n      };\n    }\n\n    // Update all metrics accordingly\n    updateMetrics(probeName, res.duration);\n  });\n}\n\nfunction getEventLoopData() {\n  // Build JSON\n  var eventLoopEvent = {\n    count: eventLoopMetrics.count,\n    minimum: eventLoopMetrics.minimum,\n    maximum: eventLoopMetrics.maximum,\n    average: eventLoopMetrics.average,\n  };\n\n  // Reset values\n  eventLoopMetrics.count = 0;\n  eventLoopMetrics.minimum = null;\n  eventLoopMetrics.maximum = null;\n  eventLoopMetrics.averageRunningTotal = 0;\n\n  return eventLoopEvent;\n}\n\nfunction getCpuData() {\n  var count = cpuMetrics.count;\n  var system = count ? cpuMetrics.system / count : 0;\n  var user = count ? cpuMetrics.user / count : 0;\n  var cpuEvent = {\n    system: assertPositive(system),\n    user: assertPositive(user),\n    total: assertPositive(system + user),\n    count: count,\n  };\n\n  // Reset values\n  cpuMetrics.system = 0;\n  cpuMetrics.user = 0;\n  cpuMetrics.count = 0;\n\n  return cpuEvent;\n}\n\nfunction getHttpData() {\n  var httpEvent = {\n    count: httpMetrics.count\n  };\n\n  // Reset Count\n  httpMetrics.count = 0;\n\n  return httpEvent;\n}\n\nfunction getProbeData(probeName) {\n\n  // Get data for given probe\n  var probeData = probeMetrics[probeName];\n  var count = probeData.count;\n  var average = count ? probeData.runningTotal / count : 0;\n\n  var probeEvent = {\n    count: count,\n    minimum: probeData.min,\n    maximum: probeData.max,\n    average: average\n  };\n\n  // Reset values\n  probeMetrics[probeName] = undefined;\n\n  return probeEvent;\n}\n\nfunction getHeapData() {\n  var jsonToReturn = heapMetrics;\n\n  // Reset JSON\n  heapMetrics = {};\n\n  return jsonToReturn;\n}\n\nfunction getGcHeapData() {\n  if (gcMetrics.count > 0) {\n    var usedHeap = gcMetrics.used / gcMetrics.count;\n\n    // Reset values\n    gcMetrics.used = 0;\n    gcMetrics.count = 0;\n  } else {\n    usedHeap = -1;\n  }\n  return usedHeap;\n}\n\nfunction getMessageData() {\n  var oldMessageMetrics = messageMetrics;\n  messageMetrics.sent = 0;\n  messageMetrics.received = 0;\n  return oldMessageMetrics;\n}\n\nfunction compareHistograms(oldHistogram, newHistogram) {\n  var objectCounts = {};\n\n  // Add all the instances currently in the heap.\n  for (var type in newHistogram) {\n    var newTuple = newHistogram[type];\n    var oldTuple = oldHistogram[type];\n    var diffTuple;\n    if (!oldTuple) {\n      diffTuple = newTuple;\n    } else {\n      diffTuple = {\n        count: newTuple.count - oldTuple.count,\n        size: newTuple.size - oldTuple.size,\n      };\n    }\n    objectCounts[type] = diffTuple;\n  }\n\n  // Account for any types where all instances have been deleted.\n  for (type in oldHistogram) {\n    oldTuple = oldHistogram[type];\n    diffTuple = objectCounts[type];\n    if (!diffTuple) {\n      diffTuple = {\n        count: 0 - oldTuple.count,\n        size: 0 - oldTuple.size,\n      };\n      objectCounts[type] = diffTuple;\n    }\n  }\n\n  return objectCounts;\n}\n\nfunction initialise() {\n  // Set up listeners for all the metrics here\n  createEventLoopListener();\n  createCpuListener();\n  createHeapListener();\n  createGcListener();\n  createMessageListener();\n  createHttpListener();\n\n  for (var i in probeList) {\n    // Create listeners for all probes\n    createProbeListener(probeList[i]);\n  }\n}\n\nfunction updateMetrics(probeName, value) {\n\n  var metrics = probeMetrics[probeName];\n\n  // update metrics accordingly (and if they haven't been defined yet)\n  if (!metrics.min || value < metrics.min) {\n    metrics.min = value;\n  }\n  if (!metrics.max || value > metrics.max) {\n    metrics.max = value;\n  }\n\n  // Update other values accordingly\n  metrics.runningTotal += value;\n  metrics.count++;\n}\n\nfunction lrtime() {\n  start();\n  return appmetrics.lrtime();\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/dashboard.js":"// Copyright IBM Corp. 2017. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar url = require('url');\nvar util = require('util');\n\nexports = module.exports = function dashboard(uri, appmetrics, dashboard) {\n  var options = {\n    appmetrics: appmetrics,\n    users: {},\n  };\n  util._extend(options, parse(uri));\n\n  if (!options.path)\n    return {};\n\n  // appmetrics-dash calls the path 'url' XXX(sam) maybe it should not?\n  options.url = options.path;\n\n  options.docs = process.env.STRONGLOOP_DASHBOARD_DOCS;\n  options.title = process.env.STRONGLOOP_DASHBOARD_TITLE;\n\n  dashboard.attach(options);\n\n  return options;\n};\n\nexports._parse = parse;\n\n// uri is:\n// - ''\n// - 'off'\n// - 'on'\n// - http://<host>:<port><path>\nfunction parse(uri) {\n  var options = {};\n\n  if (!uri)\n    return options;\n\n  if (uri === '')\n    return options;\n\n  if (uri === 'off')\n    return options;\n\n  if (uri === 'on') {\n    options.path = '/appmetrics-dash';\n    return options;\n  }\n\n  uri = url.parse(uri);\n  if (uri.pathname === '/')\n    delete uri.pathname;\n\n  options.path = uri.pathname || '/appmetrics-dash';\n\n  assign('host', 'hostname');\n  assign('port', 'port');\n\n  function assign(to, from) {\n    if (uri[from] != null && uri[from] !== '') {\n      options[to] = uri[from];\n    }\n  }\n\n  return options;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/debug.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar debug = require('debug');\nvar name = require('../package.json').name;\nvar MAX = 120;\n\nfunction json(js) {\n  // Don't json encode the string if debug is disabled.\n  if (this.enabled) {\n    var s = JSON.stringify(js);\n\n    if (s.length < MAX)\n      return s;\n\n    return s.substring(0, MAX) + '...';\n  }\n  return '';\n}\n\nmodule.exports = function(tag) {\n  var fn = debug(name + ':' + tag);\n  fn.json = json;\n  return fn;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/agent.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n// Don't require agent until needed, early require causes its configuration to\n// be loaded from the CWD, and the CWD isn't the directory of the application\n// until run has had a chance to chdir() into it.\n\n'use strict';\n\nmodule.exports = agent;\n\nfunction agent() {\n  // XXX sl-run.js sets the agent logger, and the quiet option, that won't\n  // happen if strongops isn't being used, unless we figure out a way to do it\n  // here.\n  var adapter = require('./adapter');\n\n  return adapter;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/app.js":"// Copyright IBM Corp. 2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar os = require('os');\nvar path = require('path');\n\nexports.host = host;\nexports.name = name;\n\nfunction name() {\n  try {\n    return require(path.resolve('package.json')).name;\n  } catch (e) {\n  }\n}\n\nfunction host() {\n  var host = os.hostname();\n  // XXX strip domain from host for uniformity?\n  return host;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/capabilities.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar _ = require('lodash');\nvar agent = require('./agent');\nvar async = require('async');\n\n/*\n * List of capabilities that can be queries through the capabilities API.\n *\n * Check functions callback takes two arguments:\n *\n * {boolean} status Whether the check was successful.\n * {string} reason A user friendly explination of the reason the check failed.\n *\n * Reason messages should state what feature they are in reference to, and\n * must be properly formatted. Capitalize the first word of each sentence, and\n * terminate with a period.\n *\n * eg: 'Tracing license is missing or expired.'\n */\n\n/* 7/2/2015\n * The heap and CPU profilers are supported on all platforms and\n * architectures.  CPU profiling in watchdog mode is only supported on\n * Linux (and soon OS X) on x86 and x64.\n */\n\nvar capabilities = {\n  watchdog: {\n    name: 'Smart profiling',\n    checks: [\n      {\n        check: function(cb) {\n          cb(false, 'Appmetrics does not support smart profiling.');\n        }\n      },\n    ]\n  },\n  // This was a legacy StrongOps feature, aka 'Slow Endpoints', it is not\n  // strong-trace. It was enabled via presence of env var STRONGLOOP_TRACING.\n  tracing: {\n    name: 'Tracing',\n    checks: [\n      {\n        check: function(cb) {\n          cb(false, 'Appmetrics does not support tracing.');\n        }\n      },\n    ]\n  },\n  metrics: {\n    name: 'Metrics',\n    checks: [\n      {\n        check: function(cb) {\n          if (agent().metrics) {\n            cb(true);\n          } else {\n            cb(false, 'Metrics is disabled.');\n          }\n        }\n      },\n    ]\n  },\n  cpuprofile: {\n    name: 'CPU profiling',\n    checks: []\n  },\n  heapsnapshot: {\n    name: 'Heap snapshot',\n    checks: [\n      {\n        check: function(cb) {\n          var heapdump = require('heapdump');\n          if (heapdump) {\n            cb(true);\n          } else {\n            cb(false, 'Heap snapshot not compiled.');\n          }\n        }\n      }\n    ]\n  },\n  patch: {\n    name: 'patch',\n    checks: [\n      {\n        check: function(cb) {\n          if (agent().dyninst.metrics) {\n            cb(true);\n          } else {\n            cb(false,\n              'Appmetrics does not support dynamic instrumentation.');\n          }\n        }\n      }\n    ]\n  },\n  debugger: {\n    name: 'debugger',\n    checks: [\n      {\n        check: function(cb) {\n          var dbg = require('./debugger');\n          if (dbg) {\n            cb(true);\n          } else {\n            cb(false, 'Strong-debugger not compiled.');\n          }\n        }\n      }\n    ]\n  },\n};\n\nfunction listCapabilities() {\n  return Object.keys(capabilities);\n}\n\nfunction queryCapabilities(featureName, callback) {\n  var feature = capabilities[featureName];\n\n  if (feature == null) {\n    callback(false, ['Unknown capability.']);\n    return;\n  }\n\n  var status = true;\n\n  async.map(feature.checks, function(check, callback) {\n    check.check(function(result, reason) {\n      status = status && result;\n      callback(null, reason);\n    });\n  }, function(err, reasons) {\n    if (err) {\n      callback(false, ['Could not verify support.']);\n      return;\n    }\n\n    callback(status, _.compact(reasons));\n  });\n}\n\nmodule.exports = {\n  list: listCapabilities,\n  query: queryCapabilities\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/chdir.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n// Implementation of chdir, that tracks the PWD, the logical 'symlink aware'\n// working directory that the shell builtin `cd` normally maintains. Note that\n// the CWD is different, it's the physical working directory, process.cwd() or\n// getcwd(3) returns this, and includes no symlinks.\n\n'use strict';\n\nvar path = require('path');\nvar fs = require('fs');\n\n// Ensure PWD is set, and correctly points to CWD.\nif (process.env.PWD == null) {\n  // PWD was never set, perhaps we weren't run by a shell. Set PWD.\n  process.env.PWD = process.cwd();\n} else if (process.cwd() !== fs.realpathSync(process.env.PWD)) {\n  // PWD was set, but its not a logical equivalent of our CWD. Reset PWD.\n  process.env.PWD = process.cwd();\n}\n\nmodule.exports = function chdir(directory) {\n  var pwd = path.resolve(process.env.PWD, directory);\n  process.chdir(pwd);\n  // Note that we only set PWD if chdir was successful.\n  process.env.PWD = pwd;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/config.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n// Evaluate configuration of supervisor, based on command line options,\n// strong-cluster-control configuration, and strong-agent configuration.\n\n// Some environment variable property names were defined by `rc`, and cannot be\n// changed for reasons of backwards compatibility.\n/*eslint camelcase:0*/\n\n'use strict';\n\n// May set options in process.env, so run first.\ntry {\n  var options = require('./options').parse(process.argv);\n} catch (er) {\n  if (er.code != null) {\n    console.error('%s', er.message);\n    return process.exit(er.code);\n  }\n  console.error(er.stack);\n  return process.exit(1);\n}\n\nvar Logger = require('./logger');\nvar chdir = require('./chdir'); // side effect: ensures correct process.env.PWD\nvar cluster = require('cluster');\nvar control = require('strong-cluster-control');\nvar debug = require('./debug')('config');\nvar dotenv = require('dotenv');\nvar path = require('path');\nvar runctl = require('./runctl');\nvar sendMetrics = require('./metrics');\nvar startCmd = require('./start-command');\nvar watcher = require('./watcher');\nvar transformer = require('strong-log-transformer');\nvar util = require('util');\n\nvar logger = new Logger(process.stderr);\n\n// Attach targeted control listener to cluster, for both master and workers.\nrequire('./targetctl');\n\n// Wrap watcher start, for use in master and workers.\nfunction watcherStart(parentCtl) {\n  watcher.start(parentCtl, cluster, control, module.exports);\n}\n\nif (cluster.isWorker) {\n  module.exports = {\n    isWorker: true,\n    isMaster: false,\n    logger: logger,\n    profile: process.env.supervisor_profile !== 'false',\n    enableTracing: !!process.env.STRONGLOOP_TRACING,\n    watcher: watcherStart,\n    sendMetrics: sendMetrics,\n  };\n  return;\n}\n\nvar pidfile = require('./pidfile');\nvar LogWriter = require('./log-writer');\nvar generateLogName = require('./expander').expand;\nvar SysLogStream = options.syslog && require('./syslog-stream');\n\nif (options.help) {\n  console.log(options.HELP);\n  process.exit(0);\n}\n\nif (options.version) {\n  console.log('v%s (%s, %s)',\n    V('..'), F('appmetrics'), F('strong-cluster-control'));\n  process.exit(0);\n}\n\nfunction P(pkg) {\n  return require(path.join(pkg, 'package.json'));\n}\nfunction V(pkg) {\n  return P(pkg).version;\n}\nfunction N(pkg) {\n  return P(pkg).name;\n}\nfunction F(pkg) {\n  return util.format('%s v%s', N(pkg), V(pkg));\n}\n\nvar config = options.cluster;\n\n// Allow module consumers to use our logger\nconfig.logger = logger;\n\n// Reset argv so the runner options are not seen by app\nprocess.argv = process.argv.slice(0, 2).concat(options.args);\n\n// Communicate profile options to the worker using the environment, and master\n// using config.\nprocess.env.supervisor_profile = options.profile;\nconfig.profile = options.profile;\n\nif (options.enableTracing) process.env.STRONGLOOP_TRACING = 1;\n\nvar app = startCmd(process.env.PWD, process.argv);\nif (app.error) {\n  console.error('Invalid app (%s), try `%s --help`.\\n',\n                app.error.message || app.error, options.NAME);\n  process.exit(1);\n}\n\nchdir(app.cwd);\noptions.args[0] = app.path;\nprocess.argv[2] = app.path;\n\n// Load the app's .env after we are in its working directory, and before\n// cluster.setupMaster() snapshots the environment.\ndotenv.load({silent: true});\n\n// Set the metrics URL in the environment after .env is loaded, so that the\n// CLI options override environment.\nif (options.metrics) {\n  process.env.STRONGLOOP_METRICS = options.metrics;\n}\n\ncluster.setupMaster({\n  // XXX(rmg): node 0.11.x broke compatibility with 0.10.x for when process.argv\n  //           is read and loaded into cluster.settings, so we have to manually\n  //           reset args, exec, and execArgv after our changes\n  //           see https://github.com/joyent/node/pull/7682 for upstream fix.\n  args: process.argv.slice(2),\n  exec: process.argv[1],\n  execArgv: process.execArgv,\n  // All worker output is being processed as individual log streams, so we can't\n  // just let the supervisor's stdout/stderr be inherited.\n  silent: true\n});\n\nvar supervisorLog = process.stdout;\n// If the logname doesn't change with input, the logs aren't per-worker\nvar isPerWorker = (generateLogName(options.log, {pid: 1, id: 1}) !==\n                    generateLogName(options.log, {pid: 2, id: 2}));\n\nif (options.syslog) {\n  var errorLogger = new SysLogStream({level: 'CRIT'});\n  var stdLogger = new SysLogStream({level: 'NOTICE'});\n  supervisorLog = stdLogger;\n  console.error('supervisor (%d) logging to syslog', process.pid);\n} else if (!options.syslog && options.log && options.log !== '-') {\n  supervisorLog = new LogWriter(process, options);\n  console.error('supervisor (%d) logging to \\'%s\\'',\n                process.pid, supervisorLog.name);\n}\n\n// In the recommended mode where worker logs are piped through the\n// supervisor's stdout, each worker adds 6 listeners (3 per output stream)\n// for piping alone. The default is 10.\nsupervisorLog.setMaxListeners(0);\n\nlogger.sink = transformer({\n  tag: options.logDecoration ? {pid: process.pid, worker: 0} : null,\n  timeStamp: options.timeStampSupervisorLogs,\n});\nlogger.sink.pipe(supervisorLog);\n\nconfig.start = function start() {\n  config.setupChildLogger = setupChildLogger;\n\n  cluster.on('fork', setupChildLogger);\n\n  logger.info('supervisor starting (pid %d)', process.pid);\n\n  if (options.pid) {\n    try {\n      pidfile.create(options.pid);\n    } catch (er) {\n      console.error('supervisor failed to create pid file: %s', er.message);\n      process.exit(1);\n    }\n  }\n\n  // Re-require this so that strong-agent (which may be required by now)\n  // notices, and attaches cluster control instrumentation.\n  require('strong-cluster-control');\n\n  control.on('start', function() {\n    runctl.notifyStarted();\n\n    if (!options.channel) return;\n\n    logger.info('supervisor listening on \\'%s\\'', options.channel);\n\n    runctl.start({\n      channel: options.channel,\n      logger: logger,\n    });\n  });\n  control.on('setSize', function() {\n    logger.info('supervisor size set to', this.options.size);\n  });\n  control.on('resize', function() {\n    logger.info('supervisor resized to', this.options.size);\n  });\n  control.on('startWorker', function(w) {\n    logger.info('supervisor started worker %d (pid %d)', w.id, w.process.pid);\n  });\n  control.on('stopWorker', function(w) {\n    logger.info('supervisor stopped worker %d (pid %d)', w.id, w.process.pid);\n  });\n  control.on('stop', function() {\n    logger.info('supervisor stopped');\n    process.exit(); // XXX should not be necessary!\n  });\n  cluster.on('exit', function(worker, code, signal) {\n    var exit = worker.suicide ? 'expected' : 'accidental';\n    logger.error('supervisor worker id %s (pid %d) %s exit with %s',\n                  worker.id, worker.process.pid, exit, signal || code\n                 );\n  });\n\n  var lastSignal = null;\n  process.on('exit', function(code) {\n    if (code === 0 && lastSignal) {\n      process.kill(process.pid, lastSignal);\n      return;\n    }\n    logger.error('supervisor exiting with code %d', code);\n  });\n\n  process.once('SIGINT', function() {\n    logger.warn('received SIGINT, shutting down');\n    lastSignal = 'SIGINT';\n    control.stop();\n  });\n  process.once('SIGTERM', function() {\n    logger.warn('received SIGTERM, shutting down');\n    lastSignal = 'SIGTERM';\n    control.stop();\n  });\n  process.on('SIGHUP', function() {\n    logger.warn('received SIGHUP, restarting workers');\n    try {\n      chdir(process.env.PWD);\n    } catch (er) {\n      logger.error('failed to chdir to \\'%s\\': %s', process.env.PWD, er);\n    }\n    control.restart();\n  });\n\n  if (supervisorLog !== process.stdout) {\n    process.on('SIGUSR2', function() {\n      logger.warn('received SIGUSR2, re-opening log files');\n      supervisorLog.reOpen();\n      for (var id in cluster.workers) {\n        if (cluster.workers[id].logFile !== supervisorLog) {\n          cluster.workers[id].logFile.reOpen();\n        }\n      }\n      logger.info('log files reopened');\n    });\n  }\n\n  this.sendMetrics(runctl.parentCtl, function() {\n    // Wait until metrics has started before starting cluster control, because\n    // the workers need to know what ephemeral port the statsd server is\n    // listening on in order to send it metrics.\n    // XXX(sam) above should no longer be true, since we use node ipc to\n    // send metrics, not an ephemeral port. side effect of the delay is\n    // that the first 'status' notification occurs before control is started,\n    // so the setSize part of strong-cluster-control.status() is not yet set.\n    debug('cluster-control size: %j', config.size);\n    if (config.size < 0) {\n      // Fork this number of workers... but don't restart them. Mostly used\n      // as `-1` by arc.\n      for (var size = 0; size > config.size; size--) {\n        cluster.fork();\n      }\n      delete config.size;\n    }\n    control.start({size: config.size});\n  });\n\n  this.watcher(runctl.parentCtl);\n\n  function setupChildLogger(worker) {\n    var tag = {pid: worker.process.pid, worker: worker.id};\n    var logStream = isPerWorker\n                  ? new LogWriter(worker, options)  // cleaned up by pipe()\n                  : supervisorLog;                  // cleaned up by exit()\n    var outLog = transformer({\n      timeStamp: options.timeStampWorkerLogs,\n      tag: options.logDecoration ? tag : null\n    });\n    var errLog = transformer({\n      timeStamp: options.timeStampWorkerLogs,\n      tag: options.logDecoration ? tag : null,\n      mergeLines: true\n    });\n    // When we have per-worker logs, each worker gets their own LogWriter, which\n    // gets cleaned up when the stream piped into it emits 'end'.\n    // When we don't have per-worker logs, we need to suppress the propagation\n    // of 'end' from the pipe so we don't close the supervisor's log the first\n    // time a worker exits.\n    worker.process.stdout.pipe(outLog)\n                         .pipe(stdLogger || logStream, {end: isPerWorker});\n    worker.process.stderr.pipe(errLog)\n                         .pipe(errorLogger || logStream, {end: isPerWorker});\n    worker.logFile = logStream;\n  }\n};\n\nconfig.sendMetrics = sendMetrics;\nconfig.watcher = watcherStart;\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/debugger.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar debug = require('./debug')('debugger');\ntry {\n  module.exports = require('strong-debugger');\n} catch (err) {\n  debug('Cannot load strong-debugger: %s', err.message);\n  module.exports = null;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/errors.js":"// Copyright IBM Corp. 2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nexports.ExitError = function ExitError(message, code) {\n  var self = new Error(message);\n  self.code = code == null ? 1 : code;\n  self.name = 'ExitError';\n  return self;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/expander.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar printfReplacer = require('./printf-replacer');\n\nexports.expand = function(str, worker) {\n  return printfReplacer(str || '', workerParams(worker));\n};\n\nfunction workerParams(worker) {\n  var vars = {};\n  if ('id' in worker)\n    vars.w = worker.id;\n  if ('pid' in worker)\n    vars.p = worker.pid;\n  if ('appName' in worker) // normalize dots out of app names\n    vars.a = String(worker.appName).replace(/\\./g, '-');\n  if ('hostname' in worker) // truncate hostname to first component\n    vars.h = String(worker.hostname).replace(/\\..*/, '');\n  return vars;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/printf-replacer.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nmodule.exports = printfReplacer;\n\nfunction printfReplacer(template, replacements) {\n  if (!(replacements instanceof Object)) {\n    return template;\n  }\n\n  return template.replace(/%[^%]/mg, function(match, offset, string) {\n    var char = match[1];\n    var escaped = offset > 0 && string[offset - 1] === '%';\n    if (!escaped && char in replacements) {\n      match = replacements[char];\n    }\n    return match;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/logger.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar util = require('util');\n\nmodule.exports = Logger;\n\nfunction Logger(sink) {\n  if (!(this instanceof Logger)) return new Logger(sink);\n\n  this.sink = sink;\n}\n\nLogger.prototype.info = partial(LevelLog, 'INFO');\nLogger.prototype.log = Logger.prototype.info;\nLogger.prototype.warn = partial(LevelLog, 'WARN');\nLogger.prototype.error = partial(LevelLog, 'ERROR');\n\nfunction LevelLog(level/*, items... */) {\n  var items = [].slice.call(arguments, 1);\n  this.sink.write(level + ' ' +\n                  util.format.apply(util, items) +\n                  '\\n');\n}\n\nfunction partial(fn/*, firstArgs... */) {\n  var firstArgs = [].slice.call(arguments, 1);\n  return function() {\n    var args = firstArgs.concat([].slice.call(arguments));\n    return fn.apply(this, args);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/metrics.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar Statsd = require('strong-statsd');\nvar agent = require('./agent');\nvar app = require('./app');\nvar assert = require('assert');\nvar cluster = require('cluster');\nvar master = require('strong-cluster-control');\nvar debug = require('./debug')('metrics');\nvar expandString = require('./expander').expand;\n\ntry {\n  var syslog = require('strong-fork-syslog');\n} catch (er) {\n  debug('syslog optional dep not present');\n}\n\nfunction sendMetrics(parentCtl, callback) {\n  callback = callback || function() {};\n\n  // Scenarios:\n  //   no STRONGLOOP_METRICS, return\n  //\n  //   called from master:\n  //     needs to .start() with expanded scope\n  //       if invalid, warn, and clear env... so children don't warn\n  //     needs to wait for start\n  //     needs to reset STRONGLOOP_METRICS *before* starting cluster\n  //       statsd://:PORT/SCOPE-TEMPLATE\n  //\n  //\n  //   called from worker:\n  //     needs to .start() with expanded scope (will always be a statsd: URL)\n  //\n  //   called from single-instance:\n  //     needs to .start() with expanded scope (can reset env, its ok)\n\n  var self = this;\n  var endpoints = parse(process.env.STRONGLOOP_METRICS);\n\n  function parse(url) {\n    if (url == null)\n      return [];\n    try {\n      return JSON.parse(url);\n    } catch (er) {\n      return [url];\n    }\n  }\n\n  if (cluster.isMaster) {\n    endpoints.push('internal:');\n  }\n\n  if (!endpoints.length) {\n    process.nextTick(callback);\n    return false;\n  }\n\n  var server = Statsd({\n    scope: '%a.%h.%w',\n    expandScope: expandScope,\n    flushInterval: process.env.STRONGLOOP_FLUSH_INTERVAL,\n    syslog: syslog,\n  });\n\n  debug('metrics endpoints: %j', endpoints);\n\n  endpoints.forEach(function(endpoint) {\n    try {\n      server.backend(endpoint);\n      if (cluster.isMaster) {\n        self.logger.info('supervisor reporting metrics to `%s`', endpoint);\n      }\n    } catch (er) {\n      console.error('Invalid metrics endpoint `%s`: %s', endpoint, er.message);\n      process.exit(1);\n    }\n  });\n\n  // Internal metrics support, forwarded over node ipc from cluster master\n  // to parent.\n  if (parentCtl) {\n    server.on('metrics', forwardMetrics);\n  }\n\n  server.start(function(er) {\n    assert.ifError(er);\n\n    process.env.STRONGLOOP_METRICS = server.url;\n    agent().use(function(name, value) {\n      server.send(name, value);\n    });\n    return callback(server);\n  });\n\n  if (this.setupChildLogger && server.child) {\n    var statsdWorker = {\n      process: {\n        stdout: server.child.stdout,\n        stderr: server.child.stderr,\n        pid: process.pid,\n      },\n      id: 'statsd',\n    };\n    this.setupChildLogger(statsdWorker);\n  }\n\n  function expandScope(scope) {\n    return expandString(scope, {\n      id: (cluster.worker && cluster.worker.id) | 0,\n      pid: process.pid,\n      hostname: app.host(),\n      appName: app.name(),\n    });\n  }\n\n  function forwardMetrics(metrics) {\n    debug('received: %j', metrics);\n    parentCtl.notify({cmd: 'metrics', metrics: injectIdentifiers(metrics)});\n  }\n\n  return true;\n}\n\nfunction injectIdentifiers(metrics) {\n  var wid;\n  var m;\n  for (wid in metrics.processes) {\n    m = metrics.processes[wid];\n    m.wid = wid;\n    if (cluster.workers[wid]) {\n      m.pid = cluster.workers[wid].process.pid;\n      m.pst = cluster.workers[wid].startTime;\n    } else {\n      m.pid = process.pid;\n      m.pst = master.startTime;\n    }\n  }\n  return metrics;\n}\n\nmodule.exports = sendMetrics;\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/options.js":"// Copyright IBM Corp. 2013,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\n// XXX(sam) I feel a bit bad about not using an options parsing module, but I\n// was going in circles searching npmjs.org for one which would parse options in\n// order up to the first non-option (as getopt_long could do), and failing. I'll\n// keep looking, but in the meantime, this works fine.\nvar ExitError = require('./errors').ExitError;\nvar defaults = require('strong-url-defaults');\nvar fmt = require('util').format;\nvar fs = require('fs');\nvar os = require('os');\nvar syslogAvailable = false;\nvar url = require('url');\n\ntry {\n  syslogAvailable = !!require('strong-fork-syslog');\n} catch (e) {\n  /* eslint no-empty:0 */\n}\n\nexports.NAME = process.env.SLC_COMMAND ?\n  'slc ' + process.env.SLC_COMMAND :\n  'slr';\nexports.HELP = fs.readFileSync(require.resolve('../bin/sl-run.txt'), 'utf-8')\n  .replace(/%MAIN%/g, exports.NAME)\n  .trim();\n\n// Parse argv into options (for runner), and split off the args (for the app).\nexports.parse = function parse(argv) {\n  var options = {\n    NAME: exports.NAME,\n    HELP: exports.HELP,\n    argv: argv,         // process.argv stripped of command...\n    args: ['.'],        // app app-options...\n    enableTracing: false,\n    profile: true,\n    channel: process.env.STRONGLOOP_CONTROL || 'runctl',\n    log: false,\n    metrics: null,\n    timeStampWorkerLogs: true,\n    timeStampSupervisorLogs: true,\n    logDecoration: true,\n    syslog: false,\n  };\n  // cluster_size is for compatibility with strong-cluster-control@1.x\n  var cluster = process.env.STRONGLOOP_CLUSTER;\n  if (cluster == null || cluster === '') {\n    cluster = 'CPU';\n  }\n  for (var i = 2; i < argv.length; i++) {\n    var option = argv[i];\n    if (option === '-h') {\n      options.help = true;\n\n    } else if (option === '--help') {\n      options.help = true;\n\n    } else if (option === '-v') {\n      options.version = true;\n\n    } else if (option === '--version') {\n      options.version = true;\n\n    } else if (option === '--log' || option === '-l') {\n      i++;\n      options.log = argv[i];\n\n    } else if (/^--log=/.test(option)) {\n      options.log = value(option, options.log);\n\n    } else if (option === '--syslog') {\n      options.syslog = syslogAvailable;\n\n    } else if (option === '--metrics' || option === '-m') {\n      i++;\n      options.metrics = options.metrics || [];\n      options.metrics.push(argv[i]);\n      options.profile = true;\n\n    } else if (/^--metrics=/.test(option)) {\n      options.metrics = options.metrics || [];\n      options.metrics.push(value(option));\n      options.profile = true;\n\n    } else if (option === '--pid' || option === '-p') {\n      i++;\n      options.pid = argv[i];\n\n    } else if (/^--pid=/.test(option)) {\n      options.pid = value(option, options.pid);\n\n    } else if (option === '--profile') {\n      options.profile = true;\n\n    } else if (option === '--no-profile') {\n      options.profile = false;\n      options.metrics = null;\n      delete process.env.STRONGLOOP_METRICS;\n\n    } else if (option === '--trace') {\n      options.enableTracing = true;\n\n    } else if (option === '--cluster') {\n      i++;\n      cluster = argv[i];\n\n    } else if (/^--cluster=/.test(option)) {\n      cluster = value(argv[i], cluster);\n\n    } else if (option === '--no-cluster') {\n      cluster = 'no';\n\n    // Only -C,--control,--no-control are documented, now, to align with\n    // strong-pm. The others are legacy, to be deleted sometime.\n    } else if (/^--(control|port|addr|path)$/.test(option)) {\n      i++;\n      options.channel = argv[i];\n\n    } else if (option === '-C') {\n      i++;\n      options.channel = argv[i];\n\n    } else if (/^--(control|port|addr|path)=/.test(option)) {\n      options.channel = value(option, options.channel);\n\n    } else if (option === '--no-control') {\n      options.channel = false;\n\n    } else if (option === '--no-channel') {\n      options.channel = false;\n\n    } else if (option === '--no-timestamp-workers') {\n      options.timeStampWorkerLogs = false;\n\n    } else if (option === '--no-timestamp-supervisor') {\n      options.timeStampSupervisorLogs = false;\n\n    } else if (option === '--no-log-decoration') {\n      options.logDecoration = false;\n\n    } else {\n      options.argv = argv.slice(0, i);\n      options.args = argv.slice(i);\n      break;\n    }\n  }\n\n  if (options.syslog) {\n    options.timeStampSupervisorLogs = false;\n    options.timeStampWorkerLogs = false;\n  }\n\n  if (options.metrics) {\n    options.metrics = JSON.stringify(options.metrics);\n  }\n\n  options.cluster = {\n    isWorker: false,\n    isMaster: true,\n  };\n\n  if (/cpu/i.test(cluster)) {\n    // --cluster=cpu, --cluster=CPUs\n    options.cluster.size = os.cpus().length;\n  } else if (/^-?[0-9]+$/.test(cluster)) {\n    // --cluster=[-]N, N is 0, 1, ...\n    options.cluster.size = +cluster;\n  } else {\n    throw new ExitError(fmt('Invalid cluster option: %s', cluster));\n  }\n  var protocol;\n  // The protocol includes the colon on parsing!\n  var protocolMap = {\n    'http:': 'http',\n    'https:': 'http',\n    'ws:': 'ws',\n    'wss:': 'wss',\n    // Default will be 'ws'\n  };\n  if (options.channel && (protocol = url.parse(options.channel).protocol)) {\n    options.channel = defaults(options.channel, {\n      path: 'supervisor-control'\n    }, {\n      protocol: protocolMap[protocol] || 'ws',\n    });\n    process.env.STRONGLOOP_CONTROL = options.channel;\n    options.channel = false;\n  } else {\n    delete process.env.STRONGLOOP_CONTROL;\n  }\n  return options;\n};\n\nfunction value(option, def) {\n  // '--pid=' is the same as option not present\n  var opt = /^--[^=]+=(.*)/.exec(option)[1];\n  if (opt !== '') {\n    return opt;\n  }\n  return def;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/pidfile.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar fs = require('fs');\n\n// Stale files are readable, but don't have the pid of a currently existing\n// process in them.\nfunction isStale(file) {\n  try {\n    var pid = fs.readFileSync(file) | 0; // Coerce non-numerics to 0\n  } catch (er) {\n    // File doesn't exist, or can't be accessed, not stale\n    return false;\n  }\n\n  if (pid < 1) {\n    // Pid's less than 1 do not exist, it is stale\n    return true;\n  }\n\n  try {\n    process.kill(pid, 0);\n  } catch (er) {\n    if (er.code === 'ESRCH') {\n      // Pid does not exist, it is stale\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Unlink if possible, ignore if not\nfunction unlink(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (er) {\n    /* eslint no-empty:0 */\n  }\n}\n\n// Write pidfile, errors on failure, including pre-existence of file\nfunction write(file, pid) {\n  fs.writeFileSync(file, pid, {flag: 'wx'});\n}\n\nfunction create(file) {\n  if (isStale(file)) {\n    unlink(file);\n  }\n  write(file, process.pid);\n\n  process.on('exit', unlink.bind(null, file));\n\n  // We don't unlink on SIGINT or SIGTERM, because those could be handled and\n  // recovered from, 'exit' is absolutely final.\n}\n\nfunction exists(file) {\n  return !isStale(file);\n}\n\nmodule.exports = create;\nmodule.exports.create = create;\nmodule.exports.exists = exists;\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/runctl.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\n// run-time control channel\n\nvar agentVersion = require('appmetrics/package.json').version;\nvar app = require('./app');\nvar async = require('async');\nvar cluster = require('cluster');\nvar debug = require('./debug')('runctl');\nvar EventEmitter = require('events').EventEmitter;\nvar fs = require('fs');\nvar master = require('strong-cluster-control');\nvar npmls = require('strong-npm-ls');\nvar os = require('os');\nvar targetctl = require('./targetctl');\nvar util = require('util');\nvar wsChannel = require('strong-control-channel/ws-channel').connect;\nvar processChannel = require('strong-control-channel/process').attach;\n\nvar debuggerVersion = 'n/a';\ntry {\n  debuggerVersion = require('strong-debugger/package.json').version;\n} catch (err) {\n  debug('Cannot load strong-debugger: ', err.message);\n}\n\nexports.start = start;\nexports.onRequest = onRequest; // For testing\n\n// Return the number of event listeners.\nvar listenerCount = EventEmitter.listenerCount || function(emitter, event) {\n  return emitter.listeners(event).length;\n};\n\n// sent on startup and with every status message\nvar osVersion = {\n  platform: os.platform(),\n  arch: os.arch(),\n  release: os.release()\n};\n\nvar ctlChannel = {\n  notify: function notify(req) {\n    debug('notify: ipcctl? %j %s', !!ipcctl, debug.json(req));\n    if (ipcctl) {\n      ipcctl.notify(req);\n    }\n    server.notify(req);\n  },\n};\n// Expose runctl using local domain server\nvar server = require('strong-control-channel/server').create(onRequest);\n\n// Expose runctl using node IPC only in the master/supervisor (workers\n// attach targetctl to the master).\nvar ipcctl = null;\nif (cluster.isMaster && !process.env.SL_RUN_SKIP_IPCCTL) {\n  var wsUrl = process.env.STRONGLOOP_CONTROL;\n  if (wsUrl) {\n    debug('runctl connect: %s', wsUrl);\n    ipcctl = wsChannel(onRequest, wsUrl);\n    ipcctl.on('error', function(err) {\n      console.error('strong-supervisor: lost connection to control channel: %s',\n                    err.message);\n      process.exit(1);\n    });\n    ipcctl.unref();\n  } else if (process.send) {\n    debug('runctl connect: <process channel>');\n    ipcctl = processChannel(onRequest);\n  }\n}\n\nif (cluster.isMaster) {\n  exports.notifyStarted = function() {\n    // Must not be done synchronously in the require, we don't know the app name\n    // until after run has found the app, and change to its directory.\n    ctlChannel.notify({\n      wid: 0,\n      cmd: 'started',\n      pid: process.pid,\n      ppid: 0,  // Value is not known for the master process\n      pst: master.startTime,\n      appName: app.name(),\n      agentVersion: agentVersion,\n      debuggerVersion: debuggerVersion,\n      nodeVersion: process.version,\n      osVersion: osVersion,\n      setSize: master.size,\n    });\n\n    // Status notifications usually come after every fork and exit, but if there\n    // are no forks, we still want at least one status notification sent. Note\n    // that size may be undefined, which isn't > or < than 1.\n    if (!(master.options.size >= 1)) {\n      notifyStatus();\n    }\n  };\n\n  cluster.on('listening', function(worker, address) {\n    debug('listening');\n    ctlChannel.notify({\n      cmd: 'listening',\n      wid: worker.id,\n      pid: worker.process.pid,\n      pst: worker.startTime,\n      address: address,\n    });\n  });\n\n  exports.parentCtl = ctlChannel;\n\n  master.on('fork', function(worker) {\n    debug('fork');\n    ctlChannel.notify({\n      cmd: 'fork',\n      wid: worker.id,\n      pid: worker.process.pid,\n      ppid: process.pid,\n      pst: worker.startTime,\n    });\n    notifyStatus();\n  });\n\n  cluster.on('exit', function(worker, code, signal) {\n    ctlChannel.notify({\n      cmd: 'exit',\n      wid: worker.id,\n      pid: worker.process.pid,\n      pst: worker.startTime,\n      suicide: worker.suicide,\n      reason: signal || code,\n    });\n    notifyStatus();\n  });\n}\n\nfunction notifyStatus() {\n  var status = clusterStatus();\n  status.cmd = 'status';\n  ctlChannel.notify(status);\n}\n\nfunction start(options) {\n  var logger = options.logger;\n\n  // XXX(sam) I don't like this 'last one wins' approach, but its impossible to\n  // prevent the channel outliving sl-run under all conditions, this is the only\n  // robust way I've found.\n  try {\n    fs.unlinkSync(options.channel);\n  } catch (er) {\n    /* eslint no-empty:0 */\n    // Didn't exist\n  }\n\n  server.listen(options.channel);\n\n  server.on('error', function(er) {\n    logger.error('control channel failed to listen on `%s`: %s',\n                 options.channel, er);\n    throw er;\n  });\n\n  master.on('stop', function() {\n    server.close();\n  });\n  return server;\n}\n\nfunction onRequest(req, callback) {\n  /* eslint no-redeclare:0 */\n  debug('request %s', debug.json(req));\n\n  var cmd = req.cmd;\n  var rsp = {\n  };\n\n  if (cmd === 'status') {\n    rsp = clusterStatus();\n  } else if (cmd === 'npm-ls') {\n    rsp = null;\n    npmls.read('.', function(er, data) {\n      return callback(er ? {error: er.message} : data);\n    });\n  } else if (cmd === 'set-size') {\n    try {\n      if (/cpu/i.test(req.size))\n        req.size = os.cpus().length;\n      else\n        req.size = +req.size;\n      master.setSize(req.size);\n    } catch (er) {\n      rsp.error = er.message;\n    }\n\n  } else if (cmd === 'stop') {\n    try {\n      master.stop();\n    } catch (er) {\n      rsp.error = er.message;\n    }\n\n  } else if (cmd === 'restart') {\n    try {\n      process.chdir(process.env.PWD);\n    } catch (er) {\n      // Ignore, things will probably go poorly, but we don't want the master to\n      // die even if the working directory becomes inaccessible, or the PWD,\n      // probably a current link, becomes invalid.\n    }\n    try {\n      master.restart();\n    } catch (er) {\n      rsp.error = er.message;\n    }\n\n  } else if (cmd === 'disconnect') {\n    cluster.disconnect();\n\n  } else if (cmd === 'fork') {\n    rsp = null;\n    var worker = cluster.fork();\n    // worker emits its own 'fork' _after_ s-c-c has augmented it\n    worker.once('fork', function() {\n      var rsp = {\n        workerID: worker.id,\n        processID: worker.process.pid,\n        pst: worker.startTime,\n      };\n      callback(rsp);\n    });\n\n  } else if (cmd === 'env-set') {\n    for (var k in req.env) {\n      process.env[k] = req.env[k];\n    }\n    rsp = requestAllTargets(req, callback);\n\n  } else if (cmd === 'env-unset') {\n    for (var k in req.env) {\n      delete process.env[req.env[k]];\n    }\n    rsp = requestAllTargets(req, callback);\n\n  } else if (cmd === 'tracing') {\n    var enabled = !!process.env.STRONGLOOP_TRACING;\n    if (req.enabled && !enabled) {\n      process.env.STRONGLOOP_TRACING = 1;\n    } else if (!req.enabled && enabled) {\n      delete process.env.STRONGLOOP_TRACING;\n    } else {\n      return;\n    }\n\n    try {\n      master.restart();\n    } catch (er) {\n      rsp.error = er.message;\n    }\n\n  } else if (cmd === 'signal') {\n    if (req.pid !== process.pid) {\n     // Do nothing\n    } else if (listenerCount(process, req.signame) > 0) {\n      // If there are any listeners for this signal, emit it on the\n      // process object.\n      process.emit(req.signame);\n    } else {\n      // If there are no listeners, use the default action.\n      process.kill(process.pid, req.signame);\n    }\n\n  } else {\n    // Pass any others off to the target\n    rsp = requestOfTarget(req, rsp, callback);\n  }\n\n  if (callback && rsp) {\n    process.nextTick(callback.bind(null, rsp));\n  }\n}\n\nfunction requestAllTargets(req, callback) {\n  console.log('forwarding to all workers:', req);\n  var wIds = [];\n  for (var w in cluster.workers) {\n    wIds.push(cluster.workers[w].id);\n  }\n  async.map(wIds, forwardToWorker, makeResponse);\n  return null;\n\n  function forwardToWorker(wid, next) {\n    var wreq = JSON.parse(JSON.stringify(req));\n    wreq.target = wid;\n    console.log('forwarding %j', wreq);\n    requestOfTarget(wreq, {}, function(rsp) {\n      next(null, rsp);\n    });\n  }\n\n  function makeResponse(_, res) {\n    callback(res);\n  }\n}\n\nfunction requestOfTarget(req, rsp, callback) {\n  debug('requestOfTarget %j', req);\n\n  if (targetctl.request(+req.target, req, wrapCallback)) {\n    rsp = null;\n  } else {\n    rsp.error = util.format('target %s not found', req.target);\n  }\n\n  return rsp;\n\n  function wrapCallback(rsp) {\n    // add pst field in master since workers don't know their own pst\n    var target = cluster.workers[+rsp.target] || master;\n    rsp.pst = target.startTime;\n    if (rsp.notify) {\n      ctlChannel.notify(rsp.notify);\n      delete rsp.notify;\n    }\n\n    callback(rsp);\n  }\n}\n\nfunction clusterStatus() {\n  var mStatus = master.status();\n  // pst is used by PM, startTime is set by strong-cluster-control\n  mStatus.master.pst = mStatus.master.pst || mStatus.master.startTime;\n  mStatus.appName = app.name();\n  mStatus.agentVersion = agentVersion;\n  mStatus.debuggerVersion = debuggerVersion;\n  mStatus.nodeVersion = process.version;\n  mStatus.osVersion = osVersion;\n  return mStatus;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/targetctl.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar agent = require('./agent');\nvar assert = require('assert');\nvar cluster = require('cluster');\nvar cpuProfileWatcher = require('./watcher/cpu-profile');\nvar debug = require('./debug')('targetctl');\nvar fmt = require('util').format;\nvar fs = require('fs');\nvar capabilities = require('./capabilities');\nvar heapdump = null;\nvar async = require('async');\nvar strongDebugger = require('./debugger');\nvar extend = require('util')._extend;\n\n// override any other options since some of them will break us\nprocess.env.NODE_HEAPDUMP_OPTIONS = 'nosignal';\ntry {\n  heapdump = require('heapdump');\n} catch (e) {\n  /* eslint no-empty:0 */\n  /* Ignore. Heapdump is optional. */\n}\n\nmodule.exports = require('strong-control-channel/cluster')(onRequest);\n\nfunction getWorkerInfo() {\n  var workerId = cluster.isMaster ? 0 : cluster.worker.id;\n  var workerPid = cluster.isMaster ? process.pid : cluster.worker.process.pid;\n\n  return {\n    id: workerId,\n    pid: workerPid,\n  };\n}\n\nfunction queryCapabilities(req, rsp, callback) {\n  var features = req.feature;\n  var support = rsp.capabilities = {};\n\n  if (typeof features === 'string') {\n    features = features.split(',');\n  } else {\n    features = capabilities.list();\n  }\n\n  async.map(features, function(feature, callback) {\n    capabilities.query(feature, function(status, reasons) {\n      support[feature] = {\n        status: status,\n        reasons: reasons\n      };\n\n      callback(null, support[feature]);\n    });\n  }, function(err) {\n    if (err) {\n      rsp.error = err.message;\n    }\n\n    callback(rsp);\n  });\n}\n\nfunction dumpHeap(req, rsp, callback) {\n  if (!heapdump) {\n    rsp.error = 'heap snapshot not supported, addon not built';\n    return callback(rsp);\n  }\n  var filePath = fmt('node-%d-%d.heapdump', process.pid, Date.now());\n  var worker = getWorkerInfo();\n\n  // test if file is writable. heapdump module does not give verbose errors yet\n  try {\n    var fd = fs.openSync(filePath, 'w');\n    fs.closeSync(fd);\n  } catch (err) {\n    rsp.error = err.message;\n    return callback(rsp);\n  }\n\n  rsp.notify = {\n    wid: worker.id,\n    pid: worker.pid,\n    cmd: 'heap-snapshot',\n    isRunning: false,\n  };\n\n  var result = heapdump.writeSnapshot(filePath, function() {\n    fs.readFile(filePath, function(err, profile) {\n      if (err)\n        rsp.error = err.message;\n      else\n        rsp.profile = String(profile);\n\n      fs.unlink(filePath, function(err) {\n        debug('Failed to unlink %j: %s', filePath, err);\n      });\n\n      callback(rsp);\n    });\n  });\n\n  if (!result) {\n    rsp.error = 'heap dump failed';\n    return callback(rsp);\n  }\n}\n\nfunction onRequest(req, callback) {\n  /* eslint no-redeclare:0 */\n  var cmd = req.cmd;\n  var worker = getWorkerInfo();\n\n  var rsp = {\n  };\n\n  try {\n    switch (cmd) {\n      // Capabilities Query\n      case 'query-capabilities':\n        return queryCapabilities(req, rsp, callback);\n\n      // Heap Snapshot\n      case 'heap-snapshot':\n        return dumpHeap(req, rsp, callback);\n\n      // Object Tracking\n      case 'start-tracking-objects':\n        agent().metrics.startTrackingObjects();\n        rsp.notify = {\n          wid: worker.id,\n          pid: worker.pid,\n          cmd: 'object-tracking',\n          isRunning: true,\n        };\n        break;\n\n      case 'stop-tracking-objects':\n        agent().metrics.stopTrackingObjects();\n        rsp.notify = {\n          wid: worker.id,\n          pid: worker.pid,\n          cmd: 'object-tracking',\n          isRunning: false,\n        };\n        break;\n\n      // CPU Profiling\n      case 'start-cpu-profiling':\n        agent().metrics.startCpuProfiling(req.timeout);\n        if (req.stallout) cpuProfileWatcher.stallout(req.stallout);\n        rsp.notify = {\n          wid: worker.id,\n          pid: worker.pid,\n          cmd: 'cpu-profiling',\n          isRunning: true,\n          timeout: req.timeout,\n          stallout: req.stallout,\n        };\n        break;\n\n      case 'stop-cpu-profiling':\n        agent().metrics.stopCpuProfiling(function(profile) {\n          rsp.profile = profile;\n          rsp.notify = {\n            wid: worker.id,\n            pid: worker.pid,\n            cmd: 'cpu-profiling',\n            isRunning: false,\n          };\n          callback(rsp);\n        });\n        return;\n\n      // Dynamic Instrumentation\n      case 'patch':\n        assert(agent().dyninst.metrics,\n          'agent is not configured to report metrics');\n        var err = agent().dyninst.metrics.patch(req.patch);\n\n        if (err && err.error) {\n          rsp.error = fmt('patch failed: %s on %j', err.error, err.patch);\n        }\n\n        break;\n\n      case 'env-get':\n        rsp.env = process.env;\n        break;\n\n      case 'env-set':\n        for (var k in req.env) {\n          console.log('worker set %s=%s', k, req.env[k]);\n          process.env[k] = req.env[k];\n        }\n        break;\n\n      case 'env-unset':\n        for (var k in req.env) {\n          console.log('master unset %s', req.env[k]);\n          delete process.env[req.env[k]];\n        }\n        break;\n\n      case 'dbg-start':\n        return startDebugger(req, rsp, callback);\n\n      case 'dbg-stop':\n        return stopDebugger(req, rsp, callback);\n\n      case 'dbg-status':\n        return debuggerStatus(req, rsp, callback);\n\n      // Unsupported\n      default:\n        rsp.error = 'unsupported';\n        break;\n    }\n  } catch (err) {\n    rsp.error = err.message;\n  }\n\n  debug('request %s => response %s', debug.json(req), debug.json(rsp));\n\n  callback(rsp);\n}\n\nfunction startDebugger(req, rsp, callback) {\n  if (cluster.isMaster) {\n    rsp.error = 'Cannot debug the supervisor process itself.';\n    return callback(rsp);\n  }\n\n  if (!strongDebugger) {\n    rsp.error = 'Cannot load the debugger module.';\n    return callback(rsp);\n  }\n\n  strongDebugger.start(0, function(err, port) {\n    rsp.error = err && err.message;\n    rsp.port = port;\n    addDebuggerStatusNotification(rsp);\n    callback(rsp);\n  });\n}\n\nfunction stopDebugger(req, rsp, callback) {\n  if (cluster.isMaster) {\n    rsp.error = 'Cannot debug the supervisor process itself.';\n    return callback(rsp);\n  }\n\n  if (!strongDebugger) {\n    rsp.error = 'Cannot load the debugger module.';\n    return callback(rsp);\n  }\n\n  strongDebugger.stop(function() {\n    addDebuggerStatusNotification(rsp);\n    callback(rsp);\n  });\n}\n\nfunction addDebuggerStatusNotification(rsp) {\n  var worker = getWorkerInfo();\n  rsp.notify = {\n    wid: worker.id,\n    pid: worker.pid,\n    cmd: 'debugger-status',\n  };\n  extend(rsp.notify, strongDebugger.status());\n}\n\nfunction debuggerStatus(req, rsp, callback) {\n  if (cluster.isMaster) {\n    rsp.error = 'Cannot debug the supervisor process itself.';\n    return callback(rsp);\n  }\n\n  if (!strongDebugger) {\n    rsp.error = 'Cannot load the debugger module.';\n    return callback(rsp);\n  }\n\n  rsp.status = strongDebugger.status();\n  callback(rsp);\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/watcher/cpu-profile.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar agent = require('../agent');\nvar debug = console.log; // Will be re-assigned during initialization\n\nvar stallout;\nvar stalls;\n\nexports.stallout = function(_stallout) {\n  debug('set stallout %j (was %j stalls %j)', _stallout, stallout, stalls);\n\n  stallout = _stallout;\n  stalls = 0;\n};\n\nexports.worker = function(handle) {\n  debug = handle.debug;\n\n  agent().internal.on('watchdogActivationCount', function(count) {\n    if (!stallout) return;\n    if (!count) return; // It's 0 if no stalls have occurred.\n\n    stalls += count;\n\n    handle.debug('stallout %j stalls %j (new %j)', stallout, stalls, count);\n\n    if (stalls < stallout)\n      return;\n\n    agent().metrics.stopCpuProfiling(function(err, profile) {\n      if (err) {\n        console.error('stop cpu profiler on stalls %j failed: %s', stalls, err);\n      } else {\n        handle.emit({\n          cmd: 'cpu:profile-data',\n          stalls: stalls,\n          stallout: stallout,\n          profile: profile,\n          // stopTime: Date.now(), XXX could be useful, but doesn't have a user\n        });\n      }\n    });\n    stallout = 0;\n  });\n};\n\nexports.master = function(handle) {\n  exports.worker(handle); // Masters can be watchdogged.\n\n  handle.on('cpu:profile-data', function(msg, worker) {\n    msg.pst = worker.startTime;\n    msg.wid = worker.id;\n    msg.pid = worker.process.pid;\n    handle.send(msg);\n\n    handle.send({\n      cmd: 'cpu-profiling',\n      wid: worker.id,\n      isRunning: false,\n      pid: worker.process.pid,\n      pst: worker.startTime,\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/start-command.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar debug = require('./debug')('start-command');\nvar fs = require('fs');\nvar path = require('path');\n\nmodule.exports = exports = resolveArgs;\n\n// for tests\nexports.resolvePath = resolvePath;\nexports.resolvePackageFromPath = resolvePackageFromPath;\nexports.resolveDir = resolveDir;\nexports.fromStart = fromStart;\n\n// We want to be in the directory of the file we are running so we can pick up\n// configuration stored in it's working directory, so part of resolving the path\n// of the script is also resolving what directory the script should be run from.\nfunction resolveArgs(pwd, argv) {\n  var replacer = symlinkReplacer(pwd);\n  var cwd = fs.realpathSync(pwd);\n  var script = argv[2] || '.';\n  debug('resolving CWD: %j, path: %j', cwd, script);\n  var app = resolvePath(cwd, script);\n  var stat = app.stat;\n  if (app.error) {\n    return app;\n  }\n\n  if (stat.isFile()) {\n    // given path was either foo/app.js that exists or foo/app that doesn't\n    // exist but which node would treat ass foo/app.js, so we'll just find the\n    // the package's root directory and use that as the CWD when running the\n    // specified script.\n    return replacer(resolvePackageFromPath(app.cwd, app.path));\n  }\n\n  if (stat.isDirectory()) {\n    // The given path is a directory, so now we want to find the nearest\n    // package.json, use it as the CWD, and then perform an `npm start` like\n    // script resolution.\n    var absolutePath = path.resolve(app.cwd, app.path);\n    var pkgApp = resolvePackageFromPath(absolutePath);\n\n    // 1. try parsing scripts.start from the package.json\n    var pkgStart = resolvePackageStart(pkgApp.cwd);\n    if (!pkgStart.error) {\n      return replacer(pkgStart);\n    }\n\n    // 2. try server.js, app.js, index.js**, then default module resolution\n    // ** We explicitly check for index.js even though it will be checked by\n    //    the node module resolver because we prefer it over the package's main\n    //    in cases where they are different.\n    pkgApp.path = ifExists(pkgApp.cwd, 'server.js') ||\n                  ifExists(pkgApp.cwd, 'app.js') ||\n                  ifExists(pkgApp.cwd, 'index.js') ||\n                  requireable(pkgApp.cwd, pkgApp.path);\n    if (pkgApp.path) {\n      return replacer(pkgApp);\n    }\n  }\n\n  // The package.json doesn't say how to run it, and node can't decide.. time\n  // to error out and let the user know they need to be more specific.\n  return {error: Error('app is not a file or a directory ')};\n}\n\nfunction resolvePath(cwd, script) {\n  var app = {\n    cwd: cwd,\n    path: script,\n  };\n\n  try {\n    app.stat = fs.statSync(path.resolve(app.cwd, app.path));\n  } catch (er) {\n    // app.path isn't accessible, it may be a JS file given without the .js\n    // extension, which is something that `node` and require() both honour.\n    try {\n      app.path = require.resolve(path.resolve(app.cwd, app.path));\n      app.stat = fs.statSync(app.path);\n    } catch (er) {\n      // nope, it's just plain not there, giving up.\n      app.error = er;\n    }\n  }\n\n  return app;\n}\n\nfunction ifExists(base, file) {\n  return fs.existsSync(path.resolve(base, file)) ? file : null;\n}\n\nfunction requireable(cwd, script) {\n  try {\n    var absolutePath = path.resolve(cwd, script);\n    var requirePath = require.resolve(absolutePath);\n    // it is important to return a relative path in case there are symlinks in\n    // the path, otherwise we are returning the absolute \"real\" path, because\n    // that's what node does when it resolves module paths. In other words, it\n    // would totally mess up supervisor's CWD/PWD/chdir efforts.\n    return path.relative(cwd, requirePath);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction resolvePackageFromPath(cwd, relative) {\n  var absolute = path.resolve(cwd, relative || '');\n  var dir = path.dirname(absolute);\n  var file = path.basename(absolute);\n  if (!relative) {\n    dir = absolute;\n    file = '';\n  }\n  // walk up the path until we find the package.json nearest to the app\n  while (!ifExists(dir, 'package.json')) {\n    file = path.join(path.basename(dir), file);\n    // hit root, return the fallback to running the script in its directory\n    if (dir === path.dirname(dir)) {\n      file = path.basename(absolute);\n      dir = path.dirname(absolute);\n      break;\n    }\n    dir = path.dirname(dir);\n  }\n  return {cwd: dir, path: file, error: null};\n}\n\nfunction resolveDir(cwd, dir) {\n  var app = {\n    cwd: path.resolve(cwd, dir),\n    path: ifExists(cwd, 'server.js') || ifExists(cwd, 'app.js') || '.',\n    error: null,\n  };\n  return app;\n}\n\nfunction resolvePackageStart(cwd) {\n  var pkgJSON = path.resolve(cwd, 'package.json');\n  var pkg = null;\n  try {\n    pkg = JSON.parse(fs.readFileSync(pkgJSON, 'utf8'));\n  } catch (e) {\n    return {error: Error('Could not read ' + pkgJSON)};\n  }\n  return fromStart(cwd, pkg.scripts && pkg.scripts.start);\n}\n\nfunction fromStart(cwd, script) {\n  var scriptRegexp = /^(\\S+)((?:\\s+-\\S+)*)?(?:\\s+(\\S+))(\\s.*)?$/;\n  // use same default as npm\n  var parts = scriptRegexp.exec(script || 'node server.js');\n  // TODO: support extracting node options like --expose_gc and --harmony and\n  // alternative executors, like coffee.\n  // app.execPath = parts[1];\n  // app.execArgs = parts[2];\n  var resolved = ifExists(cwd, parts[3]) || requireable(cwd, parts[3]);\n  debug('script: [%j] %j => %j => %j via: ',\n        cwd, script, parts[3], resolved,\n        parts);\n  if (!resolved) {\n    return {error: Error('Could not resolve start script ' + script)};\n  }\n  return {cwd: cwd, path: resolved};\n}\n\nfunction symlinkReplacer(link) {\n  var real = fs.realpathSync(link);\n  if (real === link) {\n    return passThrough;\n  }\n  return replace;\n  function replace(app) {\n    if (app.cwd) {\n      app.cwd = app.cwd.replace(real, link);\n    }\n    return app;\n  }\n  function passThrough(app) {\n    return app;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/syslog-stream.js":"// Copyright IBM Corp. 2014,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar util = require('util');\nvar stream = require('stream');\nvar syslog = require('strong-fork-syslog');\n\nvar initialized = false;\n\nmodule.exports = SysLogStream;\n\nfunction SysLogStream(options) {\n  if (!(this instanceof SysLogStream)) return new SysLogStream(options);\n\n  stream.Writable.call(this);\n\n  this.level = syslog.LOG_NOTICE;\n\n  if (typeof options.level === 'number') {\n    this.level = options.level;\n  } else if (typeof options.level === 'string') {\n    if (options.level.toUpperCase() in syslog) {\n      this.level = syslog[options.level];\n    } else if ('LOG_' + options.level.toUpperCase() in syslog) {\n      this.level = syslog['LOG_' + options.level.toUpperCase()];\n    }\n  }\n\n  if (!initialized) {\n    // XXX(rmg): would be nice to use the same name as strong-agent does,\n    //           ideally without duplicating the logic for deriving it.\n    syslog.init(process.title,\n                syslog.LOG_PID | syslog.LOG_ODELAY,\n                syslog.LOG_USER);\n    initialized = true;\n  }\n}\n\nutil.inherits(SysLogStream, stream.Writable);\n\nSysLogStream.prototype.reOpen = function SysLogStreamReOpen() {\n  // no-op!\n};\n\nSysLogStream.prototype._write = function _write(chunk, encoding, callback) {\n  syslog.log(this.level, chunk.toString().trim());\n  setImmediate(callback);\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/tracer.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar app = require('./app');\nvar assert = require('assert');\n\nexports = module.exports = tracer;\nexports.start = start;\n\nvar TRACER = null;\n\nvar options = {\n  archiveInterval: 20000,\n  accountKey: undefined, // Filled in later\n  useHttp: false,\n  blacklist: ['*node_modules/appmetrics/*'],\n  wrap_timers: false,\n  traceId: process.env.STRONGLOOP_TRACES_ID, // returned as hostname in trace\n};\n\nfunction tracer() {\n  return TRACER;\n}\n\nfunction start() {\n  assert(!TRACER);\n  // This is delayed to allow process.env to be modified up until start time.\n  options.accountKey = app.name();\n  if (options.accountKey) {\n    // This is delayed because requiring appmetrics causes it to monkey-patch,\n    // which should not occur unless profiling or tracing is enabled.\n    options.lrtime = require('appmetrics').lrtime;\n    TRACER = require('strong-trace')(options);\n  }\n  return TRACER;\n}\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/watcher.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\nvar assert = require('assert');\nvar debug = require('./debug')('watcher');\nvar fs = require('fs');\nvar path = require('path');\n\nvar from = path.resolve(__dirname, 'watcher');\nvar files = fs.readdirSync(from);\n\ndebug('watchers: %s', files);\n\nexports._watchers = files.map(function(f) {\n  var watcher = require(path.resolve(from, f));\n  watcher.name = f.replace('.js', '');\n  return watcher;\n});\n\nexports.start = function(parentCtl, cluster, clusterControl, config) {\n  var bus;\n\n  // parentCtl is optional\n  // cluster and strong-cluster-control are injected to allow mocking\n  assert(cluster);\n  assert(clusterControl);\n\n  if (cluster.isMaster) {\n    bus = new EventEmitter;\n\n    clusterControl.on('fork', function(worker) {\n      worker.on('message', function(msg) {\n        var cmd = msg.cmd;\n        msg = msg.msg;\n\n        switch (cmd) {\n          case 'watcher:emit':\n            debug('emit %j: %s', msg.cmd, debug.json(msg));\n            bus.emit(msg.cmd, msg, worker);\n            break;\n          case 'watcher:send':\n            debug('notify %j: %s', msg.cmd, debug.json(msg));\n            parentCtl.notify(msg);\n            break;\n          default:\n            break;\n        }\n      });\n    });\n  }\n\n  this._watchers.forEach(function(watcher) {\n    var where = cluster.isWorker ? ':worker:' : ':master:';\n\n    var debug = require('./debug')('watcher' + where + watcher.name);\n\n    if (cluster.isWorker) {\n      debug('init');\n      watcher.worker({\n        config: config,\n        debug: debug,\n        emit: function emit(msg) {\n          debug('emit %s', debug.json(msg));\n          cluster.worker.send({\n            cmd: 'watcher:emit',\n            msg: msg,\n          });\n        },\n        send: function send(msg) {\n          debug('send %s', debug.json(msg));\n          cluster.worker.send({\n            cmd: 'watcher:send',\n            msg: msg,\n          });\n        },\n      });\n      return;\n    }\n\n    if (!parentCtl) {\n      debug('no parentctl');\n      return;\n    }\n\n    assert(cluster.isMaster);\n\n    debug('init: master? %j', !!watcher.master);\n    if (watcher.master) {\n      watcher.master({\n        config: config,\n        debug: debug,\n        emit: function emit(msg) {\n          // This is master, so fake a Worker object.\n          var worker = {\n            id: 0,\n            startTime: clusterControl.startTime,\n            process: process,\n          };\n          debug('emit %j: %s', msg.cmd, debug.json(msg));\n          bus.emit(msg.cmd, msg, worker);\n        },\n        on: function on(event, listener) {\n          debug('listen on %j', event);\n          bus.on(event, listener);\n        },\n        send: function notify(msg) {\n          debug('notify %s', debug.json(msg));\n          parentCtl.notify(msg);\n        },\n      });\n    }\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/watcher/express-records.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar agent = require('../agent');\n\nexports.worker = function(handle) {\n  agent().on('express:usage-record', function(record) {\n    handle.send({\n      cmd: 'express:usage-record',\n      record: record\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/watcher/status-wd.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar app = require('../app');\nvar tracer = require('../tracer');\n\nexports.worker = function(handle) {\n  setImmediate(function() {\n    var wd = {\n      cmd: 'status:wd',\n      pwd: process.env.PWD,\n      cwd: process.cwd(),\n      pid: process.pid,\n      isTracing: !!tracer(),\n    };\n\n    wd.appName = app.name();\n\n    handle.emit(wd);\n  });\n};\n\nexports.master = function(handle) {\n  handle.on('status:wd', function(msg, worker) {\n    // Mix-in the worker identity: startTime is known only in the master, and\n    // worker.id is just convenient to do here.\n    msg.pst = worker.startTime;\n    msg.wid = worker.id;\n    handle.send(msg);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-strong-supervisor/node_modules/strong-supervisor/lib/watcher/trace-object.js":"// Copyright IBM Corp. 2015,2016. All Rights Reserved.\n// Node module: strong-supervisor\n// This file is licensed under the Artistic License 2.0.\n// License text available at https://opensource.org/licenses/Artistic-2.0\n\n'use strict';\n\nvar cluster = require('cluster');\nvar tracer = require('../tracer');\n\nexports.worker = function(handle) {\n  var config = handle.config;\n\n  if (!config.enableTracing) {\n    handle.debug('tracing is disabled');\n    return;\n  }\n\n  if (!tracer()) {\n    console.error('Did not start trace object on worker %d, license missing?',\n      cluster.worker.id);\n    return;\n  }\n\n  tracer().on('trace:object', function(record) {\n    handle.send({\n      cmd: 'trace:object',\n      record: JSON.stringify(record),\n    });\n  });\n};\n"}